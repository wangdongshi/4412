### 内容概要  

驱动模型这个东西是在分析U-Boot的时候遇到的，但是U-Boot关于设备驱动模型的设计思想完全来自于Linux内核，因此，这里以Linux内核为基础来介绍设备驱动模型（dm），以及围绕它所产生的udev、mdev、设备树（dts）等概念，以期对这一部分的理解达到融会贯通的程度。  

### 设备驱动模型  

为什么Linux中会提出设备驱动模型这个问题？在LDD第三版的第14章——Linux设备模型，对这个问题有详细的说明。简单来说，这个模型是要解决同类的多个设备是否都需要各自的驱动的问题。  

但是要理解“设备驱动模型”这一问题有很多前置条件，这是很多初学者在这个问题上屡战屡败的重要原因。  

首先要搞明白的是Linux设备驱动的基本设计步骤，它大概包含下面六点内容：  

1. 建立模块  
   实现xxx_init()，xxx_exit()这些模块相关的函数。  
2. 申请设备号  
   使用register_chrdev()申请主从设备号。  
3. 创建设备文件  
   使用mknod命令，或者采用udev/mdev工具生成代表设备的文件。  
4. 硬件初始化  
   一是io映射，二是注册中断，以上都是软件层面的游戏，这里是实质的硬件操作，在设备驱动模型中被抽象为设备的内容。  
5. 构建file_operation结构体   
   将上述要素绑定在一起。
6. 实现具体的驱动动作   
   实现xxx_open()，xxx_read()，xxx_write()等驱动相关函数。  

LDD的14章以前的大部分章节都是在讲，如何按照上述步骤为一个特定的物理设备编写一个Linux上的驱动，但是当有多个设备，特别是存在多个同类设备或同一个设备要适配多个CPU的时候，逐个为每个设备编写驱动显然是很不明智的，因为它违反了软件设计中的复用原则，为了解决这一问题，Linux中才提出了“设备驱动模型”的概念。简单说，这个概念就是要将上面的第4部分所实现的内容抽象为“设备”（device），而将其它部分所实现的内容抽象为“驱动”（driver）。  

### 模块  

先来说说Linux中模块的概念。LDD中将Module这个概念放在最前面讲解，这很容易给人造成一种误解——Module是驱动程序中的一个概念，但其实Module和驱动之前没有任何关系。没错，驱动程序完全可以做成不是模块形式的，而模块程序也不一定就是驱动程序，比如LDD一开篇写的那个Hello world的模块，它就没实现任何驱动的功能，但它仍然是一个模块。  

模块只是Linux程序的一种存在形式，从操作系统的层面来考虑，加载一个模块和加载一个普通的应用程序没有什么本质的区别。但是，模块运行在内核空间，且必须自行负责加载和卸载时的资源管理工作，这都是模块和普通应用程序的不同之处。  

